<!DOCTYPE html>
<html>
<head>
<title>Terminal - Parsegraph</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
    font-family: sans-serif;
    margin: 0;
    padding: 0;
}

.parsegraph_Surface {
    width: 100%;
    height: 100vh;
    margin: 0;
}

div {
    text-align: center;
    position: absolute;
}

.controls {
    margin: auto;
    position: absolute;
    pointer-events: none;
    width: 100%;
}

.controls > form button {
    pointer-events: auto;
}

@media only screen and (max-width: 980px) {

.controls {
    display: none;
}

body > div {
    width: 100%;
}

body > div input {
    clear: left;
}

}
</style>
<script src="parsegraph-1.2.js"></script>
<script src="parsegraph-widgets-1.2.js"></script>
<script src="esprima.js"></script>
<script>

parsegraph_FIELD_STYLE = null;

function parsegraph_CommandWidget(graph)
{
    this._graph = graph;
    this._root = new parsegraph_Node(parsegraph_BUD);

    if(!parsegraph_FIELD_STYLE) {
        parsegraph_FIELD_STYLE = parsegraph_copyStyle(parsegraph_BLOCK);
        parsegraph_FIELD_STYLE.backgroundColor = new parsegraph_Color(1, 1, 1, 1);
        parsegraph_FIELD_STYLE.borderColor = new parsegraph_Color(.5, .5, .5, 1);
    }
    this._field = this._root.spawnNode(parsegraph_FORWARD, parsegraph_BLOCK);
    this._field.setLabel("", graph.glyphAtlas());
    this._field.setKeyListener(function(key) {
        if(key !== "Enter") {
            return;
        }

        this._field.disconnectNode(parsegraph_DOWNWARD);
        this._graph.scheduleRepaint();
        this._field.connectNode(parsegraph_DOWNWARD, this.evaluate());
        this.enter();
    }, this);
}

parsegraph_CommandWidget.prototype.enter = function()
{
    if(this._enterListener) {
        this._enterListener.call(this._enterListenerThisArg);
    }
}

parsegraph_CommandWidget.prototype.setEnterListener = function(listener, listenerThisArg)
{
    this._enterListener = listener;
    this._enterListenerThisArg = listenerThisArg;
}

parsegraph_CommandWidget.prototype.glyphAtlas = function()
{
    return this._graph.glyphAtlas();
}

parsegraph_CommandWidget.prototype.content = function()
{
    return this._field.label();
}

parsegraph_CommandWidget.prototype.fieldNode = function()
{
    return this._field;
}

parsegraph_CommandWidget.prototype.evaluate = function()
{
    var res = new parsegraph_Node(parsegraph_BLOCK);
    res.setLabel(content, this.glyphAtlas());
    var content = this.content().toLowerCase();
    switch(content) {
    case "hello":
        res._label.setText("Hello there!");
        break;
    default:
        try {
            res._label.setText(eval(this.content()));
        }
        catch(ex) {
            res._label.setText(ex);
        }
    }
    return res;
}

parsegraph_CommandWidget.prototype.root = function()
{
    return this._root;
}

function parsegraph_TerminalWidget(graph)
{
    this._graph = graph;

    this._root = new parsegraph_Node(parsegraph_BLOCK);
    this._root.setLabel("parsegraph_Terminal", graph.glyphAtlas());
    this._root._label.setEditable(false);

    this._root.setKeyListener(function(key) {
        if(key !== "Enter") {
            return;
        }

        var c = this.addCommandAfter(this._root);
        this.focus(c);
        this._graph.scheduleRepaint();
    }, this);
}

parsegraph_TerminalWidget.prototype.addCommandAfter = function(cmd)
{
    var child = new parsegraph_CommandWidget(this._graph);
    if(cmd.hasNode(parsegraph_DOWNWARD)) {
        var disc = cmd.disconnectNode(parsegraph_DOWNWARD);
        cmd.connectNode(parsegraph_DOWNWARD, child.root());
        child.root().connectNode(parsegraph_DOWNWARD, disc);
    }
    else {
        cmd.connectNode(parsegraph_DOWNWARD, child.root());
    }

    child.root().setKeyListener(function(key) {
        if(key !== "Enter") {
            return;
        }
        var newC = this.addCommandAfter(child.root());
        this.focus(newC);
        this._graph.scheduleRepaint();
    }, this);

    child.setEnterListener(function() {
        if(!child.root().hasNode(parsegraph_DOWNWARD)) {
            var c = this.addCommandAfter(child.root());
            this.focus(c);
            this._graph.scheduleRepaint();
        }
    }, this);

    return child;
}

parsegraph_TerminalWidget.prototype.focus = function(cmd)
{
    this._graph.input().setFocusedNode(cmd.fieldNode());
}

parsegraph_TerminalWidget.prototype.root = function()
{
    return this._root;
}

function init()
{
    try {
        parsegraph_initialize();
        var main = document.body;

        // Create the surface.
        var surface = new parsegraph_Surface();
        main.appendChild(surface.container());

        var graph = new parsegraph_Graph(surface);
        GRAPH = graph;

        var widget = new parsegraph_TerminalWidget(graph);
        graph.world().plot(widget.root());

        var cameraName = "parsegraph_terminal_camera";
        if(localStorage.getItem(cameraName) != null) {
            try {
                var cameraData = JSON.parse(localStorage.getItem(cameraName));
                graph.camera().restore(cameraData);
            } catch(e) {
                console.log("Failed to parse saved camera state.\n" + parsegraph_writeError(e));
            }
        }

        // Schedule the repaint.
        var renderTimer = new parsegraph_AnimationTimer();
        renderTimer.setListener(function() {
            graph.input().Update(new Date());
            if(graph.needsRepaint()) {
                surface.paint(50);
            }
            surface.render();
            if(graph.input().UpdateRepeatedly() || graph.needsRepaint()) {
                renderTimer.schedule();
            }
        });
        graph.input().SetListener(function(affectedPaint, eventSource, inputAffectedCamera) {
            if(affectedPaint) {
                graph.scheduleRepaint();
            }
            renderTimer.schedule();
            if(inputAffectedCamera) {
                localStorage.setItem(cameraName, JSON.stringify(graph.camera().toJSON()));
            }
        });
        renderTimer.schedule();
        graph.onScheduleRepaint = function() {
            renderTimer.schedule();
        };
    } catch(ex) {
        alert("Init: " + parsegraph_writeError(ex));
        throw ex;
    }
}

document.addEventListener("DOMContentLoaded", function(event) {
    init();
});
</script>
</head>
<body>
</body>
</html>
