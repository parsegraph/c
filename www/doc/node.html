<!DOCTYPE html>
<html>
<head>
<title>Node - Parsegraph</title>
<link rel="stylesheet" href="style.css">
</head>
<body>

<main class="content">
<h1>Parsegraph Node</h1>
The node represents a single element in a graph.

<h3>new parsegraph_Node()</h3>
Creates a new Node of the given type, optionally connected to the given parent.
<p>
<ul>
<li>parsegraph_Node(newType) creates a new root node; the node will have no parent.</li>
<li>parsegraph_Node(newType, parentNode, parentDirection) creates a node connected to the given node in the given direction.</li>
</ul>

<h3>parsegraph_chainTab(a, b, swappedOut)</h3>
Make a's next tab node b, and link the previous tab nodes accordingly. If swappedOut is given as an array, then its first and second elements are set to the original values of [a's next tab node, b's previous tab node].
<h3>parsegraph_chainAllTabs()</h3>
Given a variable amount of nodes as arguments, chain the tab positions so that the nodes form a closed loop.
<h3>.x()</h3>
Returns the node's position relative to its parent. If the node is a root node, then 0 is returned.
<h3>.y()</h3>
Same as parsegraph_Node.prototype.x(), but for the Y-coordinate.
<h3>.scale()</h3>
Returns the scale of this node.
<h3>.setScale(scale)</h3>
Sets the scale of this node.
<p>
This value is commutative with child scales.
<p>
Calling this function will change the layout.
<h3>.setRightToLeft(val)</h3>
This sets whether the node's forward and backward nodes will be reversed.
<p>
<ul><li>If rightToLeft() == true, parsegraph_FORWARD goes to the left.
<li>If rightToLeft() == false, parsegraph_FORWARD goes to the right.
</ul>
<h3>.rightToLeft()</h3>
Returns whether this node's forward direction will be in the right-to-left direction.
<h3>.commitAbsolutePos()</h3>
Computes and saves the absolute position of this node.
<h3>.positionWasChanged()</h3>
Clears the absolute position, so that it must be recomputed using commitAbsolutePos().
<h3>.absoluteX()</h3>
Returns the absolute X-coordinate of the center of this node. The absolute position will be
computed if necessary.
<h3>.absoluteY()</h3>
Same as absoluteX(), but for the Y-coordinate.
<h3>.absoluteScale()</h3>
Same as absoluteX(), but for the scale of the node.
<h3>.setPosAt(inDirection, x, y)</h3>
Directly sets the position of the node in the given direction, relative to this node.
<h3>.setPaintGroup(paintGroup)</h3>
Sets this node's paint group to the given value, removing this node from any previous paint group if necessary. This node and its descendents will be rendered as part of the given paint group.
<h3>.findPaintGroup()</h3>
Returns the node's paint group. If this node does not have a paint group, then
the parent's is returned.
<h3>.localPaintGroup()</h3>
Directly returns the paint group set on this node, if any is set.
<h3>.graph()</h3>
Returns the graph that contains the node.
<h3>.backdropColor()</h3>
Returns the color that should be used as the background color for inward nodes.
<h3>.setClickListener(listener, thisArg)</h3>
Sets this node's click listener to the given value or clearing it if listener is null.
<h3>.setChangeListener(listener, thisArg)</h3>
Sets this node's change listener to the given value or clearing it if listener is null.
<h3>.isClickable()</h3>
Returns whether this node will receive mouse events.
<h3>.setIgnoreMouse()</h3>
Sets whether this node will ignore mouse events. This does not override the click listener.
<h3>.ignoresMouse()</h3>
Returns whether this node will ignore mouse events.
<h3>.hasClickListener()</h3>
Returns whether this Node has a click listener.
<h3>.hasChangeListener()</h3>
Returns whether this Node has a change listener.
<h3>.valueChanged()</h3>
Invokes the change listener for this node.
<h3>.click()</h3>
Invokes the click listener on this node.
<p>
Does nothing if no click listener is present.
<h3>.setKeyListener(listener, thisArg)</h3>
Sets this node's listener for key events to the given listener function.
<h3>.hasKeyListener()</h3>
Returns whether this Node has a listener to respond to key events.
<h3>.key()</h3>
Invokes the key listener on this node.
<p>
Does nothing if no key listener is present.
<h3>.nodeFit()</h3>
Returns the node fit for this node. Either parsegraph_NODE_FIT_EXACT or parsegraph_NODE_FIT_LOOSE.
<p>
Node fit affects how the separation is computed between nodes. Exact fit means that the nodes will be separated with minimal space between them. Loose fit causes the node's extent to be simplified after combining - this results in a looser fit because interlocking areas are treated as straight edges.
<h3>.setNodeFit(nodeFit)</h3>
Sets the node fit to the given value. See nodeFit() for details.
<h3>.isRoot()</h3>
Returns whether this node is a root node.
<h3>.parentDirection()</h3>
Returns the direction of this node's parent.
<h3>.nodeParent()</h3>
Returns this node's parent.
<p>
Throws parsegraph_NODE_IS_ROOT if this node is a root node.
<h3>.parentNode()</h3>
Synonym for .nodeParent().
<h3>.parent()</h3>
Synonym for .nodeParent().
<h3>.hasNode(atDirection)</h3>
Returns whether this node has a node in the given direction.
<p>
Returns false if the given direction is NULL_NODE_DIRECTION.
<h3>.hasNodes(axis)</h3>
Returns an array of node directions that indicate a node
in that direction. The directions are filtered by the given
axis.
<p>
Nodes in both directions:
[negative node direction, positive node direction]
<p>
 Node in negative direction:
 [negative node direction, parsegraph_NULL_NODE_DIRECTION]
<p>
 Node in positive direction:
 [parsegraph_NULL_NODE_DIRECTION, positive node direction]
<p>
 Node in no directions:
 [parsegraph_NULL_NODE_DIRECTION, parsegraph_NULL_NODE_DIRECTION]
 */
<h3>.hasChildAt(direction)</h3>
Returns whether this node has a child node in the given direction.
<p>
See also nodeAt(), which returns true for the parent as well.
<h3>.hasAnyNodes()</h3>
Returns whether this node has any downward, upward, forward, backward nodes.
<h3>.nodeAt(atDirection)</h3>
Returns the node in the given direction, or null if no such node exists.
<h3>.traverse(filterFunc, actionFunc, thisArg, timeout)</h3>
Iterates over this node and its children, calling actionFunc whenever
filterFunc is true.
<h3>.spawnNode(spawnDirection, newType)</h3>
Spawns a new node of the given type in the given direction. The new node is returned.
<p>
The direction must not already contain a node; an error is thrown otherwise.
<h3>.connectNode(inDirection, node)</h3>
Connects the given node to this node in the given direction. The connected node is returned.
<p>
The direction must not already contain a node; an error is thrown otherwise.
<h3>.eraseNode(givenDirection)</h3>
Synonym for .disconnectNode().
<h3>.disconnectNode(inDirection)</h3>
Removes and returns the node in the given direction.
<p>
Does nothing if no node is in the given direction.
<h3>.disconnectNode()</h3>
Removes and returns this node from its parent. If this node is a root, an error is thrown.
<h3>.eachChild(visitor, visitorThisArg)</h3>
Invokes the specified visitor for each child of this node.
<h3>.scaleAt(direction)</h3>
Returns the parent-relative scale of the node in the given direction.
<h3>.lineLengthAt(direction)</h3>
Returns the computed length of the connecting line in the given direction.
<p>
The result is unspecified if there is no node in that direction.
<h3>.extentsAt(atDirection)</h3>
Returns the computed extents of the node in the given direction.
<p>
The result is unspecified if there is no node in that direction.
<h3>.extentOffsetAt(atDirection)</h3>
Returns the offset of this node's extents in the specified direction.
<h3>.extentSize(outPos)</h3>
Returns a new parsegraph_Size object that represents the size of this node's extents. This is
equivalent to a bounding box that will cover this node and its descendents.
<p>
outPos is optionally a parsegraph_Size object that will be used instead of creating a new object.
<h3>.setLayoutPreference(given)</h3>
Sets the layout preference of this node to the given value. This value is used in determining the order of child layout. Because the first axis laid out will be closest to the parent, the second axis must separate not only from the parent, but from the first axis, which may cause it to be further separated. This can cause rendered graphs to appear like a part is popped out.
<p>
Caret uses this method to implement pull().
<h3>.setNodeAlignmentMode(newAlignmentMode)</h3>
Sets this node's alignment node for its parent. The node must have a parent, because alignment is always set on the parent.
<h3>.setNodeAlignmentMode(inDirection, newAlignmentMode)</h3>
Aligns the child in the given direction using the given node alignment mode.
<p>
The alignment can be set and changed before a node is present.
<h3>.nodeAlignmentMode(inDirection)</h3>
Returns the alignment used for the given direction.
<h3>.type()</h3>
Returns this node's type.
<h3>.setType(newType)</h3>
Sets this node's type to the new value. The style is changed as well.
<p>
This method changes the layout.
<h3>.value()</h3>
Returns this node's value.
<h3>.setValue(newValue, report)</h3>
Sets this node's value to the new value, invoking the change listener if report is true.
<h3>.scene()</h3>
Returns this node's scene, if one is set.
<h3>.setScene(scene)</h3>
Sets this node's scene to the given value.
<h3>.typeAt(direction)</h3>
Returns the type of the node in the given direction.
<h3>.label()</h3>
Returns the text of this node's label, or null if this node does not have a label.
<h3>.realLabel()</h3>
Directly returns the parsegraph_Label for this node.
<h3>setLabel(text, glyphAtlas)</h3>
Sets this node's label's text to the specified value. If the node does not already have a
label, one is created. Note that labels require glyph atlases to be created, so one must
be provided the first time setLabel() is called.
<h3>.blockStyle()</h3>
Return this node's style.
<h3>.setBlockStyle(style)</h3>
Sets this node's style.
<h3>.isSelectedAt(direction)</h3>
Returns whether the node in the given direction is selected. Returns false if there is no node in the given direction.
<h3>.sizeIn(direction)</h3>
Returns the node's size in the given direction, from its center to that direction's extreme value still within this node.
<h3>.brightnessColor()</h3>
Returns the color used for highlighting this node.
<h3>.setBrightnessColor(brightnessColor)</h3>
Sets the color used for highlighting this node to the given parsegraph_Color value.
<h3>.borderThickness()</h3>
Returns the border thickness used for this node, as given by the style.
<h3>.size(bodySize)</h3>
Returns the local size of this node. If bodySize is given, it must be a parsegraph_Size that will be populated with this node's size.
<h3>.absoluteSize(bodySize)</h3>
Returns the absolute size of this node.
<h3>.assignParent(fromNode, parentDirection)</h3>
Directly sets the parent of this node to the given node in the given parent direction.
<h3>.isSelected()</h3>
Returns whether this node is selected.
<h3>.setSelected(selected)</h3>
Sets whether this node is selected.
<h3>.horizontalPadding()</h3>
Returns the padding between the central content of the node and its border, as given by the style.
<h3>.verticalPadding()</h3>
Returns the padding between the central content of the node and its border, as given by the style.
<h3>.verticalSeparation(direction)</h3>
Returns the minimum vertical separation for the given direction.
<p>
Buds use a special separation, so the node in the given direction should be the same as the one that will be painted and rendered if the value is to be trusted.
<h3>.horizontalSeparation(direction)</h3>
Same as .verticalSeparation(direction), but for the horizontal axis.
<h3>.inNodeBody(x, y, userScale)</h3>
Returns true if the coordinates are in the node.
<h3>.inNodeExtents(x, y, userScale)</h3>
Returns true if the coordinates are in the node or its extent.
<h3>.nodeUnderCoords(x, y, userScale)</h3>
Searches for the node that contains the given position. First tests against
the body, and if that fails, tests against the extent.
<p>
The deepest node under the given coordinates is returned, or null otherwise.
<h3>.sizeWithoutPadding(bodySize)</h3>
Returns the size of this node, based on this node's type and label.
<p>
Sliders appear like blocks, though they render buds and their own lines internally.
Scenes also appear like boxes.
Consequently, since these types work like blocks, there is no special code for them here.
<h3>.commitLayout(bodySize)</h3>
Sets the position, calculates extents, and clears the needs commit flag.
<p>
If bodySize is given, it must be a parsegraph_Size that will be used during calculations.
<h3>parsegraph_findConsecutiveLength(node, inDirection)</h3>
Returns the total distance from the given node, to the furthest node
found in the given direction.
<p>
The result is in node-space; the scale of child nodes is applied.
<h3>.commitLayoutIteratively(timeout)</h3>
Commits the layout of this node and its descendents.
<p>
Returns a function that, if calculations for all nodes is not complete by the given timeout
(in milliseconds like new Date().getTime()), will continue the layout operation. If the
layout completed, null is returned, or will eventually be returned by the given function
if enough invocations are made.
<h3>.separationAt(inDirection)</h3>
Returns the separation between this node and the node
in the given direction.
<p>
Throws NO_NODE_FOUND if no node is in the given direction.
<h3>.layoutHasChanged(changeDirection)</h3>
Indicate that the layout was changed and thus needs an layout commit.
<h3>.canonicalLayoutPreference()</h3>
From this node's layout preference, compute either parsegraph_PREFER_PARENT_AXIS or parsegraph_PREFER_PERPENDICULAR_AXIS.
<h3>.destroy()</h3>
Removes all children, clears the layout state and parent direction, and resets the scale.
<h3>.dumpExtentBoundingRect()</h3>
Dumps each node's extents.
<h3>parsegraph_labeledBud(label, glyphAtlas)</h3>
Creates and returns a new labeled bud that uses the given glyph atlas.
<h3>parsegraph_labeledSlot(label, glyphAtlas)</h3>
Creates and returns a new labeled slot that uses the given glyph atlas.
<h3>parsegraph_labeledBlock(label, glyphAtlas)</h3>
Creates and returns a new labeled block that uses the given glyph atlas.
</main>

<nav class="toc">
<h2>parsegraph_Node</h2>
<ol>
<li>parsegraph_Node(newType)</li>
<li>parsegraph_Node(newType, fromNode, parentDirection)</li>
<li>parsegraph_chainTab(a, b, swappedOut)
<li>parsegraph_chainAllTabs()
<li>.x()
<li>.y()
<li>.scale()
<li>.setScale(scale)
<li>.setRightToLeft(val)
<li>.rightToLeft()
<li>.commitAbsolutePos()
<li>.positionWasChanged()
<li>.absoluteX()
<li>.absoluteY()
<li>.absoluteScale()
<li>.setPosAt(inDirection, x, y)
<li>.setPaintGroup(paintGroup)
<li>.findPaintGroup()
<li>.localPaintGroup()
<li>.graph()
<li>.backdropColor()
<li>.setClickListener(listener, thisArg)
<li>.setChangeListener(listener, thisArg)
<li>.isClickable()
<li>.setIgnoreMouse()
<li>.ignoresMouse()
<li>.hasClickListener()
<li>.hasChangeListener()
<li>.valueChanged()
<li>.click()
<li>.setKeyListener(listener, thisArg)
<li>.hasKeyListener()
<li>.key()
<li>.nodeFit()
<li>.setNodeFit()
<li>.isRoot()
<li>.parentDirection()
<li>.nodeParent()
<li>.parentNode()
<li>.parent()
<li>.hasNode(atDirection)
<li>.hasNodes(axis)
<li>.hasChildAt(direction)
<li>.hasAnyNodes()
<li>.nodeAt(atDirection)
<li>.traverse(filterFunc, actionFunc, thisArg, timeout)
<li>.spawnNode(spawnDirection, newType)
<li>.connectNode(inDirection, node)
<li>.eraseNode(givenDirection)
<li>.disconnectNode(inDirection)
<li>.disconnectNode()
<li>.eachChild(visitor, visitorThisArg)
<li>.scaleAt(direction)
<li>.lineLengthAt(direction)
<li>.extentSize(outPos)
<li>.setLayoutPreference(given)
<li>.setNodeAlignmentMode(newAlignmentMode)
<li>.setNodeAlignmentMode(inDirection, newAlignmentMode)
<li>.nodeAlignmentMode(inDirection)
<li>.type()
<li>.setType(newType)
<li>.value()
<li>.setValue(newValue, report)
<li>.scene()
<li>.setScene(scene)
<li>.typeAt(direction)
<li>.label()
<li>.realLabel()
<li>setLabel(text, glyphAtlas)
<li>.blockStyle()
<li>.setBlockStyle(style)
<li>.isSelectedAt(direction)
<li>.sizeIn(direction)
<li>.brightnessColor()
<li>.setBrightnessColor(brightnessColor)
<li>.borderThickness()
<li>.size(bodySize)
<li>.absoluteSize(bodySize)
<li>.assignParent(fromNode, parentDirection)
<li>.isSelected()
<li>.setSelected(selected)
<li>.horizontalPadding()
<li>.verticalPadding()
<li>.verticalSeparation(direction)
<li>.horizontalSeparation(direction)
<li>.inNodeBody(x, y, userScale)
<li>.inNodeExtents(x, y, userScale)
<li>.nodeUnderCoords(x, y, userScale)
<li>.sizeWithoutPadding(bodySize)
<li>.commitLayout(bodySize)
<li>parsegraph_findConsecutiveLength(node, inDirection)
<li>.commitLayoutIteratively(timeout)
<li>.separationAt(inDirection)
<li>.layoutHasChanged(changeDirection)
<li>.canonicalLayoutPreference()
<li>.destroy()
<li>.dumpExtentBoundingRect()
<li>parsegraph_labeledBud(label, glyphAtlas)
<li>parsegraph_labeledSlot(label, glyphAtlas)
<li>parsegraph_labeledBlock(label, glyphAtlas)
</ol>
</nav>
</body>
</html>
