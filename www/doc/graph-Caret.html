<!DOCTYPE html>
<html>
<head>
<title>Caret - Parsegraph</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<nav class="toc">
<h2>parsegraph_Caret</h2>
<ol>
<li>new parsegraph_Caret()</li>
<li>new parsegraph_Caret(nodeType)</li>
<li>new parsegraph_Caret(nodeRoot)</li>
<li>node()</li>
<li>has(inDirection)</li>
<li>graph()</li>
<li>root()</li>
<li>selected()</li>
<li>selected(inDirection)</li>
<li>glyphAtlas()</li>
<li>setGlyphAtlas(glyphAtlas)</li>
<li>spawn(inDirection, newType)</li>
<li>spawn(inDirection, newType, newAlignmentMode)</li>
<li>connect(inDirection, node)</li>
<li>disconnect(inDirection)</li>
<li>disconnect()</li>
<li>crease(inDirection)</li>
<li>erase(inDirection)</li>
<li>move(inDirection)</li>
<li>push()</li>
<li>save(id)</li>
<li>clearSave(id)</li>
<li>restore(id)</li>
<li>moveTo(id)</li>
<li>moveToRoot()</li>
<li>pop(id)</li>
<li>spawnMove(inDirection, newType, newAlignmentMode)</li>
<li>replace(withContent)</li>
<li>replace(inDirection, withContent)</li>
<li>at(inDirection)</li>
<li>align(inDirection, newAlignmentMode)</li>
<li>pull(given)</li>
<li>shrink(inDirection)</li>
<li>shrink()</li>
<li>grow()</li>
<li>fitExact()</li>
<li>fitLoose()</li>
<li>label(text)</li>
<li>label(text, glyphAtlas)</li>
<li>label(inDirection, text)</li>
<li>label(inDirection, text, glyphAtlas)</li>
<li>select()</li>
<li>deselect()</li>
<li>onClick(clickListener, thisArg)</li>
<li>onChange(changeListener, thisArg)</li>
<li>onKey(keyListener, thisArg)</li>
</ol>
</nav>
<main class="content">
<h1>Parsegraph Caret</h1>
The caret builds nodes to be shown in a graph.

<h2>Caret construction</h2>
 The caret begins positioned at the root node.
<ul>
<li>new parsegraph_Caret() creates and returns a new caret with a new root node of the default node type.</li>
<li>new parsegraph_Caret(nodeType) creates and returns a new caret with a new root node of the given node type.</li>
<li>new parsegraph_Caret(nodeRoot) creates and returns a new caret with the given node as the root node.</li>
</ul>

<h2>Caret getters</h2>
<h3>.node()</h3>
node() returns the current node.
<p>
The caret uses a stack of nodes to allow for saving and restoring old node
positions. node() peeks at the top of this stack.
<h3>.has(inDirection)</h3>
Returns whether the current node has a node in the given node direction.
<h3>.graph()</h3>
Returns the graph for the caret's current node.
<h3>.root()</h3>
Returns the root of the caret's node's graph.
<h3>.selected()</h3>
Returns whether the specified node is selected.
<ul>
<li>selected() returns whether the caret's current node is selected.
<li>selected(inDirection) returns whether the node in the given direction is selected.
</ul>
<h3>.glyphAtlas()</h3>
Returns the currently set glyph atlas for the caret.

<h2>Caret mutators</h2>
<h3>.setGlyphAtlas(glyphAtlas)</h3>
Changes the glyph atlas used for labeling nodes created by the caret.
<h3>.spawn()</h3>
spawn() creates and returns a node in a given direction.
<ul>
<li>spawn(inDirection, newType) creates and returns a new node of the given type</li>
<li>spawn(inDirection, newType, newAlignmentMode) creates and returns a new node of the given type, aligned using the specified alignment mode.</li>
</ul>
The node fit of the child is set to the node fit of the parent.
<p>
spawn() does not move the caret.
<h3>.connect(inDirection, node)</h3>
Connects the given node to the caret's current node in the given direction.
<h3>.disconnect()</h3>
Removes a node from the graph.
<ul>
<li>disconnect(inDirection) removes and returns the node in the given direction, making it a new root. </li>
<li>disconnect() removes and returns the current node from the graph, making it a new root.</li>
</ul>
<h3>.crease(inDirection)</h3>
Ensures that a paint group exists for the node in the given direction. That node and any descendents who do not
themselves have a paint group will be painted and rendered together.
<p>
The paint group is returned.
<h3>.erase(inDirection)</h3>
Synonymous with disconnect().
<h3>.move(toDirection)</h3>
Moves the caret node position to the node in the given direction; the node at the top of the caret's stack is replaced with the node in the given direction.
<h3>.push()</h3>
Pushes a new node onto the caret's node stack.

<h3>.save(id)</h3>
Saves the current node using the given ID. If no value is given, an
autogenerated one is used.
<p>
The ID is returned.
<h3>.clearSave(id)</h3>
Clears the saved node named by the given ID.
<h3>.restore(id)</h3>
Moves the graph to the node named by ID.
<h3>.moveTo(id)</h3>
Synonym for restore(id).
<h3>.moveToRoot()</h3>
Moves the caret to the node root.
<h3>.pop()</h3>
Pops the node at the top of the caret's stack.
<h3>.spawnMove(inDirection, newType, newAlignmentMode)</h3>
Spawns a new node in the given direction of the specified type and, optionally, alignment mode.
<h3>.replace()</h3>
Change the type of the specified node.
<ul>
<li>replace(withContent) replaces the current node.</li>
<li>replace(inDirection, withContent) replaces the node in the given direction.</li>
</ul>
<h3>.at(inDirection)</h3>
Returns the type of the node in the given direction. If no type is found, then the result is undefined.
<h3>.align(inDirection, newAlignmentMode)</h3>
Sets the alignment of the node in the given direction to the specified value.
<h3>.pull(given)</h3>
Ensures the the node in the given direction will be laid out before other siblings. The first laid-out node
will be positioned closest to the parent, and is not be displaced by siblings in other directions.
<h3>.shrink()</h3>
Reduces the scale of the given node to a single preset value.
<ul>
<li>shrink(inDirection) shrinks the node in the given direction.
<li>shrink() shrinks the caret's current node.
</ul>
<h3>.grow()</h3>
Like shrink(), but sets the scale to 1.0.
<h3>.fitExact()</h3>
Changes the node fitting of the caret's node to be exact. Exact node fittings are laid out minimally.
<ul>
<li>fitExact() sets the node fitting of the caret's current node.
<li>fitExact(inDirection) sets the node fitting of the node in the given direction.
</ul>
<h3>.fitLoose()</h3>
Like fitExact(), but sets the node fitting to be loose. Loose node fitting is calculated faster, as complex
node edges are simplified to bounding boxes during each layout step, reducing the amount needed to compute
node separation.
<h3>.label()</h3>
Sets the label of the given node. A glyph atlas must be provided if the caret does not have one.
<ul>
<li>car.label(text) sets the caret's node's label to the given text using the caret's glyph atlas.</li>
<li>car.label(text, glyphAtlas) sets the caret's node's label to the given text using the provided glyph atlas.</li>
<li>car.label(inDirection, text) sets the label of the node in the given direction to the provided text using the caret's glyph atlas.</li>
<li>car.label(inDirection, text, glyphAtlas) sets the label of the node in the given direction to the provided text using the provided glyph atlas.</li>
</ul>
<h3>.select()</h3>
Selects the given node.
<ul>
<li>select() selects the caret's current node.
<li>select(inDirection) selects the node in the given direction.
</ul>
<h3>.deselect()</h3>
Same as selected, but changes the selected state to false.
<h3>.onClick(clickListener, thisArg)</h3>
Sets the click listener for the currently positioned node to the provided function. User mouse events that map
to the rendered world coordinates of the current node will invoke the given function.
<p>
If no thisArg is given, then the current node is used.
<h3>.onChange(changeListener, thisArg)</h3>
Sets the change listener for the currently positioned node to the given function.
<h3>.onKey(keyListener, thisArg)</h3>
Sets the key listener for the currently positioned node to the given function.
</main>

</body>
</html>
