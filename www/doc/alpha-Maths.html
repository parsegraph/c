<!DOCTYPE html>
<html>
<head>
<title>Maths - Alpha</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<main class="content">
<h1>Alpha Maths</h1>
<h3>alpha_FUZZINESS</h3>
The minimum difference between numeric values to be considered non-equal.
<h3>alpha_random(min, max)</h3>
Returns an integer between min and max, inclusive.
<h3>alpha_GetTime()</h3>
Returns the time since Alpha started up, in seconds.
<h3>alpha_toRadians(inDegrees)</h3>
Converts the given degrees measure to radians.
<h3>alpha_ToRadians(inDegrees)</h3>
Alias for alpha_toRadians().
<h3>alpha_toDegrees(inRadians)</h3>
Returns the given radians measure, converted to degrees.
<h3>alpha_ToDegrees(inRadians)</h3>
Alias for alpha_toDegrees(inRadians).
<h2>Vector</h2>
Represents a mathematical vector with 3 components.
<p>
The vector can be accessed like an array.
<h3>new alpha_Vector()</h3>
Creates a new vector with all components set to zero.
<p>
The returned vector's values can be accessed like an array.
<h3>new alpha_Vector(x, y, z)</h3>
The constructor calls alpha_Vector.Set with the provided arguments.
<p>
The returned vector's values can be accessed like an array.
<h3>.length</h3>
Returns the number of components of this 3-dimensional vector.
<h3>.toJSON()</h3>
Creates and returns a new array, containing the components of this vector.
<h3>.restore(json)</h3>
Loads the components stored in the given array.
<h3>.Add(vec)</h3>
Adds the given vector to this vector.
<h3>.Add(x, y, z)</h3>
Adds the given components to this vector.
<h3>.Added(...)</h3>
Creates a clone of this Vector and adds the given vector to it.
<h3>.Clone()</h3>
Copies each component into a new vector and returns it.
<h3>.Multiply(value)</h3>
Multiplies in-place all components of this vector by the given value.
<h3>.Multiply(x, y, z)</h3>
Multiplies in-place the components of this vector by the given components.
<h3>.Multiply(vec)</h3>
Multiplies in-place the components of this vector by the given vector.
<h3>.Multiplied(...)</h3>
Clones this vector and multiplies it using the given arguments.
<h3>.Divide(...)</h3>
Same as .Multiply(...), but division.
<p>
No check for divide-by-zero is made.
<h3>.Divided(...)</h3>
Same as .Multiplied(...), but division.
<p>
No check for divide-by-zero is made.
<h3>.Equals(x, y, z)</h3>
Returns whether this vector is component-wise equal to the given components.
<h3>.Equals(other)</h3>
Returns whether this vector is component-wise equal to the given vector.
<h3>.Set(x, y, z)</h3>
Sets this vector's components to the given components.
<h3>.Set(ref)</h3>
Sets this vector's components to the given vector's components.
<h3>.Normalize()</h3>
Normalizes this vector, dividing each component by the vector's magnitude, so that the
vector's length will be 1.
<h3>.Normalized()</h3>
Clones a vector and normalizes it.
<h3>.Magnitude()</h3>
Returns the length of this vector.
<h3>.Length()</h3>
Alias for <code>.Magnitude()</code>.
<h3>.DotProduct(other)</h3>
Returns the dot-product of this vector with the given vector.
<pre>
    return this[0] * other[0] + this[1] * other[1] + this[2] * other[2];
</pre>
<h3>.InnerProduct(other)</h3>
Alias for .DotProduct(other).
<h3>.ScalarProduct(other)</h3>
Alias for .DotProduct(other).
<h3>.AngleBetween(other)</h3>
Returns the angle between this vector and the given vector.
<pre>
    var dot = this.DotProduct(other);
    return Math.acos(dot / (this.Magnitude() * other.Magnitude()));
</pre>
<h3>.toString()</h3>
Returns a developer-friendly string describing this vector.
<h2>Quaternion</h2>
Represents a quaternion, a 4-component vector with special operations.
<p>
The quaternion can be accessed like an array.
<h3>new alpha_Quaternion()</h3>
Creates a new quaternion set to [0, 0, 0, 1].
<h3>new alpha_Quaternion(x, y, z, w)</h3>
Creates a new quaternion set to the given components.
<h3>.toJSON()</h3>
Returns a new array, filled with this quaternion's component values.
<h3>.restore(json)</h3>
Sets this array to the given json array or object.
<ul>
<li>If the value is an object, then json.x, json.y, json.z, json.w is used as components.
<li>If the value is an array, then json[0], json[1], json[2], json[3] is used as components.
</ul>
<h3>.Clone()</h3>
Creates and returns a new clone of this quaternion.
<h3>.Multiply(scalar)</h3>
Multiplies each of this quaternion's values by the given scalar.
<h3>.Multiply(quat)</h3>
Multiplies this quaternion by the given quaternion.
<h3>.Multiply(x, y, z, w)</h3>
Multiplies this quaternion by the specified quaternion.
<h3>.Multiplied(...)</h3>
Creates a clone of this quaternion and calls .Multiply(), returning the product.
<h3>.RotatedVector(x, y, z)</h3>
Rotates the specified vector using this quaternion.
<h3>.RotatedVector(quat)</h3>
Rotates the given vector using this quaternion.
<h3>.RotatedVector2(x, y, z)</h3>
Rotates the specified vector using this quaternion.
<h3>.RotatedVector2(quat)</h3>
Rotates the given vector using this quaternion.
<h3>.Equals(x, y, z, w)</h3>
Returns true if this quaternion's values are fuzzily equal to the given values.
<h3>.Equals(other)</h3>
Returns true if this quaternion's values are fuzzily equal to the given quaternion.
<h3>.Magnitude()</h3>
Returns the dot-product of this quaternion.
<h3>.Length()</h3>
Alias for .Magnitude().
<h3>.Norm()</h3>
Alias for .Magnitude().
<h3>.Normalize()</h3>
Normalizes this quaternion.
<h3>.Set(other)</h3>
Sets this quaternion's values to the given quaternion's values.
<p>
If the given argument is 3-dimensional, the quaternion's current W-value is retained.
<h3>.Set(x, y, z, w)</h3>
Sets this quaternion's values to the given values.
<h3>.Conjugate()</h3>
Returns <code>new Quaternion(-this[0], -this[1], -this[2], this[3])</code>.
<h3>.Inverse()</h3>
Returns a new Quaternion that is the normalized conjugate of this quaternion.
<h3>.ToAxisAndAngle()</h3>
Returns <code>[vec, angleInRads]</code> that represents this vector.
<h3>alpha_QuaternionFromAxisAndAngle()</h3>
Creates a new quaternion that is <code>angle</code> radians around the given unit vector axis.
<p>
var q = alpha_QuaternionFromAxisAndAngle(x, y, z, angleInRads);
<h3>.FromAxisAndAngle()</h3>
Sets this quaternion to <code>angle</code> radians around the given unnormalized vector axis.
<p>
 q.FromAxisAndAngle(x, y, z, angleInRads);
<h3>.DotProduct = function(other)
Returns the dot product of this quaternion with the given quaternion.
<h3>.ScalarProduct</h3>
Alias for .DotProduct(other).
<h3>.InnerProduct()</h3>
Alias for .DotProduct(other).
<h3>.toString()</h3>
Returns a developer-friendly string describing this quaternion.
<h3>.AngleBetween(other)</h3>
Returns the angle between this quaternion and the given quaternion.
<h2>Matrices</h2>
 Constructs a 4x4 row-major Matrix.
<pre>
    // using quaternions for a Vector4
    var r1 = new alpha_Quaternion(this[0], this[1], this[2], this[3]);
    var r2 = new alpha_Quaternion(this[4], this[5], this[6], this[7]);
    var r3 = new alpha_Quaternion(this[8], this[9], this[10], this[11]);
    var r4 = new alpha_Quaternion(this[12], this[13], this[14], this[15]);
</pre>
<h3>new alpha_RMatrix4()</h3>
Creates a new identity matrix.
<h3>new alpha_RMatrix4(...)</h3>
Creates a new matrix and calls .Set() using the given arguments.
<h3>.restore(json)</h3>
Calls .Set() using the given value.
<h3>.toJSON()</h3>
Alias for .toArray().
<h3>.toDom(reference)</h3>
Creates a new HTML table that describes this matrix.
<h3>.Set(mat)</h3>
Sets the components of this matrix to the components of the given matrix.
<h3>.Set(r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4)</h3>
Sets the components of this matrix to the given values.
<h3>.Equals(mat)</h3>
Compares component-wise this matrix with the component values of the given matrix.
<h3>.Equals(...)</h3>
Compares component-wise this matrix with the given component values.
<h3>.Clone()</h3>
Creates a new matrix that is a clone of this matrix.
<h3>.Multiply(scalar)</h3>
Multiplies all components of this matrix by the given scalar value.
<h3>.Multiply(mat)</h3>
Multiplies this matrix by the given matrix.
<h3>.Transform(quat)</h3>
Alias for .Transform(quat[0], quat[1], quat[2], quat[3]);
<h3>.Transform(vec, w)</h3>
Alias for .Transform(vec[0], vec[1], vec[2], w);
<h3>.Transform(x, y, z)</h3>
Alias for .Transform(x, y, z, 1.0).
<h3>.Transform(x, y, z, w)</h3>
Returns a new quaternion that is transformed by this matrix.
<h3>.Multiplied(...)</h3>
Clones this matrix and multiplies it using the given arguments.
<h3>.Identity()</h3>
Sets the components of this matrix to the identity matrix.
<pre>
    return this.Set(
        1,0,0,0,
        0,1,0,0,
        0,0,1,0,
        0,0,0,1
    );
</pre>
<h3>.Scale(vec)</h3>
Multiplies this matrix by a scale-matrix using the given vector components.
<h3>.Scale(x, y, z)</h3>
Multiplies this matrix by a scale-matrix using the given components.
<h3>.Translate(vec)</h3>
Multiplies this matrix by a translation-matrix using the given vector components.
<h3>.Translate(x, y, z)</h3>
Multiplies this matrix by a translation-matrix using the given components.
<h3>.Rotate(quat)</h3>
Multiplies this matrix by a rotation-matrix constructed using the given quaternion.
<h3>.Rotate(x, y, z, w)</h3>
Multiplies this matrix by a rotation-matrix constructed using the given quaternion components.
<h3>.Transpose()</h3>
Swaps the rows and columns of this matrix.
<h3>.toString()</h3>
Returns a developer-friendly string describing this matrix.
<h3>alpha_RMatrix4FromEuler(...)</h3>
Constructs a new marix and calls .FromEuler(...).
<h3>.FromEuler(x, y, z)</h3>
Sets this matrix to a rotation matrix specified using the given Euler angle components.
<p>
x = pitch, y = yaw, z = roll applied in YXZ order. If you are keeping track at home: Z * X * Y
<h3>.FromEuler(vec)</h3>
Sets this matrix to a rotation matrix specified using the given Euler angle vector.
<p>
x = pitch, y = yaw, z = roll applied in YXZ order. If you are keeping track at home: Z * X * Y
<h3>alpha_RMatrix4FromQuaternion(...)</h3>
Creates a new matrix and calls .FromQuaternion(...).
<h3>.FromQuaternion(x, y, z)</h3>
Calls .FromQuaternion(x, y, z, 0).
<h3>.FromQuaternion(x, y, z, w)</h3>
Sets this matrix to the rotation-matrix specified by the given quaternion values.
<h3>.FromQuaternion(quat)</h3>
Sets this matrix to the rotation-matrix specified by the given quaternion.
<h3>alpha_RMatrix4FromQuaternionAtVector()</h3>
equivalent to rotationMatrix * translationMatrix.
<h3>alpha_RMatrix4FromVectorAroundQuaternion(...)</h3>
Alias for <code>new alpha_RMatrix4().FromVectorAroundQuaternion(...)</code>.
<h3>.FromVectorAroundQuaternion(vector, quat)</h3>
equivalent to translationMatrix * rotationMatrix.
<p>
the 4th value in this matrix multplication always end up as 0
<h3>alpha_RMatrix4FromVectorAroundQuaternionAtVector()</h3>
Alias for <code>new alpha_RMatrix4().FromVectorAroundQuaternionAtVector(...)</code>.
<h3>.FromVectorAroundQuaternionAtVector(vec1, quat, vec2)</h3>
translation * rotation * translation
<p>
TranslationMatrix(vec2) * rotationMatrix(quat) * translationMatrix(vec1)
<h3>.Inverse()</h3>
Inverts this matrix.
<h3>.Inversed()</h3>
Returns a new matrix equal to the inverse of this matrix.
<h3>.toArray()</h3>
Creates a new array with values equal to this matrix's components.
</main>
<nav class="toc">
<h2>Alpha Maths</h2>
<ol>
<li>alpha_FUZZINESS
<li>alpha_random(min, max)
<li>alpha_GetTime()
<li>alpha_toRadians(inDegrees)
<li>alpha_ToRadians(inDegrees)
<li>alpha_toDegrees(inRadians)
<li>alpha_ToDegrees(inRadians)
</ol>
<h2>Vector</h2>
<ol>
<li>new alpha_Vector()
<li>new alpha_Vector(x, y, z)
<li>.length
<li>.toJSON()
<li>.restore(json)
<li>.Add(vec)
<li>.Add(x, y, z)
<li>.Added(...)
<li>.Clone()
<li>.Multiply(value)
<li>.Multiply(x, y, z)
<li>.Multiply(vec)
<li>.Multiplied(...)
<li>.Divide(...)
<li>.Divided(...)
<li>.Equals(x, y, z)
<li>.Equals(other)
<li>.Set(x, y, z)
<li>.Set(ref)
<li>.Normalize()
<li>.Normalized()
<li>.Magnitude()
<li>.Length()
<li>.DotProduct(other)
<li>.InnerProduct(other)
<li>.ScalarProduct(other)
<li>.AngleBetween(other)
<li>.toString()
</ol>
<h2>Quaternion</h2>
<ol>
<li>new alpha_Quaternion()
<li>new alpha_Quaternion(x, y, z, w)
<li>.toJSON()
<li>.restore(json)
<li>.Clone()
<li>.Multiply()
<li>.Multiplied()
<li>.RotatedVector2()
<li>.Magnitude()
<li>.Norm()
<li>.Set()
<li>.Inverse()
<li>alpha_QuaternionFromAxisAndAngle()
<li>.FromAxisAndAngle()
<li>.DotProduct(other)
<li>.ScalarProduct(other)
<li>.InnerProduct()
<li>.toString()
<li>.AngleBetween(other)
</ol>
<h2>Matrices</h2>
<ol>
<li>new alpha_RMatrix4()
<li>new alpha_RMatrix4(...)
<li>.restore(json)
<li>.toJSON()
<li>.toDom(reference)
<li>.Set(mat)
<li>.Set(r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4)
<li>.Equals(mat)
<li>.Equals(...)
<li>.Clone()
<li>.Multiply(scalar)
<li>.Multiply(mat)
<li>.Transform(quat)
<li>.Transform(vec, w)
<li>.Transform(x, y, z)
<li>.Transform(x, y, z, w)
<li>.Multiplied(...)
<li>.Identity()
<li>.Scale(vec)
<li>.Scale(x, y, z)
<li>.Translate(vec)
<li>.Translate(x, y, z)
<li>.Rotate(quat)
<li>.Rotate(x, y, z, w)
<li>.Transpose()
<li>.toString()
<li>alpha_RMatrix4FromEuler(...)
<li>.FromEuler(x, y, z)
<li>.FromEuler(vec)
<li>alpha_RMatrix4FromQuaternion(...)
<li>.FromQuaternion(x, y, z)
<li>.FromQuaternion(x, y, z, w)
<li>.FromQuaternion(quat)
<li>alpha_RMatrix4FromQuaternionAtVector()
<li>alpha_RMatrix4FromVectorAroundQuaternion()
<li>alpha_RMatrix4FromVectorAroundQuaternionAtVector()
<li>.FromVectorAroundQuaternionAtVector(vec1, quat, vec2)
<li>.Inverse()
<li>.Inversed()
<li>.toArray()
</ol>
</nav>
</body>
</html>
