<!DOCTYPE html>
<html>
<head>
<title>JavaScript - Parsegraph</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
    font-family: sans-serif;
    margin: 0;
    padding: 0;
}

.parsegraph_Surface {
    width: 100%;
    height: 100vh;
    margin: 0;
}

div {
    text-align: center;
    position: absolute;
}

.controls {
    margin: auto;
    position: absolute;
    pointer-events: none;
    width: 100%;
}

.controls > form button {
    pointer-events: auto;
}

@media only screen and (max-width: 980px) {

.controls {
    display: none;
}

body > div {
    width: 100%;
}

body > div input {
    clear: left;
}

}
</style>
<script src="parsegraph-1.0.js"></script>
<script src="parsegraph-examples-1.0.js"></script>
<script src="esprima.js"></script>
<script>

function parsegraph_CameraProtocol(ws, camera, eventFunc, eventFuncThisArg) {
    if(!eventFunc) {
        throw new Error("An eventFunc must be provided");
    }
    var opened = false;

    var timer = new parsegraph_IntervalTimer();
    timer.setDelay(50);

    timer.setListener(function() {
        if(!opened) {
            return;
        }
        //console.log("Sending camera");
        ws.send(JSON.stringify(camera.toJSON()));
        timer.cancel();
    });

    this.update = function() {
        if(!opened) {
            return;
        }
        timer.schedule();
    };

    ws.onopen = function() {
        //console.log("Connection opened");
        opened = true;
        timer.schedule();
    };

    var state = "begin";
    var composed = "";
    ws.onmessage = function(event) {
        var msg = event.data;
        //console.log(msg);
        while(msg.length > 0) {
            if(state === "begin") {
                // Ensure the message begins as we expect.
                if(msg.charAt(0) != '{') {
                    ws.close();
                    throw new Error("Invalid start received");
                }
                state = "collecting";
            }
            if(state === "collecting") {
                var eol = msg.indexOf('}');
                if(eol != -1) {
                    // Message contains an end.
                    composed += msg.slice(0, eol + 1);
                    //console.log(composed);
                    eventFunc.call(
                        eventFuncThisArg,
                        JSON.parse(composed)
                    );

                    // Process the remaining message.
                    msg = msg.slice(eol + 1);
                    state = "begin";
                    composed = "";
                }
                else {
                    // Message continues.
                    composed += msg;
                    msg = "";
                }
            }
        }
    };

    ws.onclose = function() {
        opened = false;
        timer.cancel();
    };

    this.opened = function() {
        return opened;
    };
};

function parsegraph_ChatProtocol(ws, eventFunc, eventFuncThisArg) {
    if(!eventFunc) {
        throw new Error("An eventFunc must be provided");
    }
    var opened = false;

    this.send = function(text) {
        // Closed socket appears often as server down.
        if(ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING || !ws.readyState) {
            //console.log("WebSocket closing, ignoring: " + text);
            return;
        }
        //console.log("Sending", ws.readyState, text);
        ws.send(JSON.stringify({data:text}));
    };

    ws.onopen = function() {
        //console.log("Connection opened");
        opened = true;
    };

    var state = "begin";
    var composed = "";
    ws.onmessage = function(event) {
        var msg = event.data;
        //console.log(msg);
        while(msg.length > 0) {
            if(state === "begin") {
                // Ensure the message begins as we expect.
                if(msg.charAt(0) != '{') {
                    ws.close();
                    throw new Error("Invalid start received");
                }
                state = "collecting";
            }
            if(state === "collecting") {
                var eol = msg.indexOf('}');
                if(eol != -1) {
                    // Message contains an end.
                    composed += msg.slice(0, eol + 1);
                    //console.log(composed);
                    eventFunc.call(
                        eventFuncThisArg,
                        JSON.parse(composed)
                    );

                    // Process the remaining message.
                    msg = msg.slice(eol + 1);
                    state = "begin";
                    composed = "";
                }
                else {
                    // Message continues.
                    composed += msg;
                    msg = "";
                }
            }
        }
    };

    ws.onclose = function() {
        opened = false;
    };

    this.opened = function() {
        return opened;
    };
};

function parsegraph_JavaScriptWidget(graph)
{
    this.graph = graph;
    this.caret = new parsegraph_Caret('b');
    this.caret.label("Program");
};

/**
 * Builds a child node in the given direcction. The caret is left at a position
 * where another child node could be spawned in that direction.
 *
 * Some children do not nest themselves, so they will consist of several nodes
 * in a given direction. This means that popping back to before the child was created
 * will not yield a place for a node to be spawned in that direction. This is not
 * as common as the child consisting of a single node, so it must be the case to
 * keep in mind when constructing trees.
 *
 *  | downward inDir
 *  +== forward spawnDir
 *  |
 *
 * I expect inDir to be either parsegraph_INWARD, parsegraph_FORWARD, or
 * parsegraph_DOWNWARD.
 */
parsegraph_JavaScriptWidget.prototype.buildChild = function(child, inDir)
{
    inDir = parsegraph_readNodeDirection(inDir);
    var car = this.caret;
    switch(child.type) {
    case "Identifier":
        // Identifiers are plain ol' slots.
        car.spawnMove(inDir, 's');
        car.label(child.name);
        break;
    case 'Literal':
        // Identifiers are plain ol' slots.
        car.spawnMove(inDir, 's');
        car.label(child.raw);
        break;
    case 'ExpressionStatement':
        // Expression statements are drawn directly; make no visual note of the nested statement.
        this.buildChild(child.expression, inDir);
        break;
    case 'ReturnStatement':
        // Return statements have the keyword plus any value, in-order.
        car.spawnMove(inDir, 'b');
        car.label('return');
        if(child.argument) {
            this.buildChild(child.argument, inDir);
        }
        break;
    case 'BinaryExpression':
    case 'AssignmentExpression':
        this.buildChild(child.left, inDir);

        // Inward nodes, once inside, spawn forward.
        if(inDir === parsegraph_INWARD) {
            inDir = parsegraph_FORWARD;
        }
        car.spawnMove(inDir, 'bu');
        car.label(child.operator);
        this.buildChild(child.right, inDir);
        break;
    case 'MemberExpression':
        this.buildChild(child.object, inDir);

        // Inward nodes, once inside, spawn forward.
        if(inDir === parsegraph_INWARD) {
            inDir = parsegraph_FORWARD;
        }

        // Spawn the operator.
        car.spawnMove(inDir, 'bu');
        car.label('.');

        // Spawn the property name.
        this.buildChild(child.property, inDir);
        break;
    case 'UpdateExpression':
    case 'UnaryExpression':
        if(child.prefix) {
            // Spawn the prefix operator.
            car.spawnMove(inDir, 'bu');
            car.label(child.operator);

            // Inward nodes, once inside, spawn forward.
            if(inDir === parsegraph_INWARD) {
                inDir = parsegraph_FORWARD;
            }

            // Spawn the value.
            this.buildChild(child.argument, inDir);
        }
        else {
            // Spawn the value.
            this.buildChild(child.argument, inDir);

            // Inward nodes, once inside, spawn forward.
            if(inDir === parsegraph_INWARD) {
                inDir = parsegraph_FORWARD;
            }

            // Spawn the postfix operator.
            car.spawnMove(inDir, 'bu');
            car.label(child.operator);
        }
        break;
    case 'ThisExpression':
        car.spawnMove(inDir, 's');
        car.label('this');
        break;
    case 'BreakStatement':
        car.spawnMove(inDir, 'b');
        car.label('break');
        break;
    case 'EmptyStatement':
        car.spawnMove(inDir, 'bu');
        car.label(';');
        break;
    case 'WhileStatement':
        car.spawnMove(inDir, 'b');
        car.label('while');
        car.push();
        this.buildChild(child.test, 'f');
        car.pop();
        if(child.body) {
            car.spawnMove('d', 'bu');
            this.buildChild(child.body, 'f', 'f');
        }
        break;
    case 'BlockStatement':
        this.buildBody(child, inDir, parsegraph_turnRight(inDir));
        break;
    case 'ForStatement':
        car.spawnMove(inDir, 'b');
        car.label('for');

        car.push();
        car.pull('f');
        car.align('f', 'c');
        car.spawnMove('f', 'bu');

        car.push();
        this.buildChild(child.init, 'f');
        car.pop();
        car.pull('f');

        car.spawnMove('d', 'bu');

        car.push();
        this.buildChild(child.test, 'f');
        car.pop();

        car.spawnMove('d', 'bu');
        this.buildChild(child.update, 'f');
        car.pop();

        this.buildBody(child.body, parsegraph_DOWNWARD, parsegraph_DOWNWARD);
        break;
/*    case 'ArrayExpression':
        car.spawnMove(inDir, 'b');

        for(var i = 0; i < child.elements.length; ++i) {
            var elem = child.elements[i];
            if(i === 0) {
                car.spawnMove('i', 'bu');
                car.shrink();
                this.buildChild(elem, 'd');
            }
            else {
                car.spawnMove('f', 'bu');
                this.buildChild(elem, 'd');
            }
        }

        break;
    case 'ThrowStatement':
        car.spawnMove(inDir, 'b');
        car.label('throw');
        if(inDir === parsegraph_INWARD) {
            inDir = parsegraph_FORWARD;
        }
        this.buildChild(child.argument, inDir);
        break;
*/
    case "CallExpression":
        car.spawnMove(inDir, 'b');
        car.push();
        this.buildChild(child.callee, 'i');
        car.pop();
        if(inDir === parsegraph_INWARD) {
            inDir = parsegraph_FORWARD;
        }

        // Arguments
        car.pull(inDir);
        car.spawnMove(inDir, 'b');
        for(var i = 0; i < child.arguments.length; ++i) {
            var arg = child.arguments[i];
            if(i === 0) {
                car.shrink();
                this.buildChild(arg, 'i');
            }
            else {
                this.buildChild(arg, 'f');
            }
            if(i < child.arguments.length - 1) {
                car.spawnMove('f', 'bu');
                car.label(',');
            }
        }
        break;
    /*
    case 'NewExpression':
        car.spawnMove(inDir, 'b');
        car.label('new');
        this.buildChild(child.callee, 'i');

        if(inDir === parsegraph_INWARD) {
            inDir = parsegraph_FORWARD;
        }

        // Arguments
        car.pull(inDir);
        car.spawnMove(inDir, 'b');
        for(var i = 0; i < child.arguments.length; ++i) {
            var arg = child.arguments[i];
            if(i === 0) {
                car.spawnMove('i', 'bu');
                car.shrink();
                this.buildChild(arg, 'd');
            }
            else {
                car.spawnMove('f', 'bu');
                this.buildChild(arg, 'd');
            }
        }

        break;
*/
    case 'IfStatement':
        car.spawnMove(inDir, 'b');
        car.label('if');
        car.push();
        car.pull(inDir);
        this.buildChild(child.test, 'i');
        car.pop();

        inDir = parsegraph_alternateNodeDirection(inDir);
        car.spawnMove(inDir, 'bu');
        car.shrink();
        car.label("then");

        car.push();
        inDir = parsegraph_alternateNodeDirection(inDir);
        car.pull(inDir);
        if(parsegraph_isVerticalNodeDirection(inDir)) {
            car.align(inDir, 'center');
        }
        this.buildChild(child.consequent, inDir);
        car.pop();

        if(child.alternate) {
            if(inDir === parsegraph_DOWNWARD) {
                car.spawnMove('f', 'bu');
            }
            else {
                car.spawnMove('d', 'bu');
            }
            car.label("else");
            if(parsegraph_isVerticalNodeDirection(inDir)) {
                car.align(inDir, 'center');
            }
            this.buildChild(child.alternate, inDir);
        }

        break;
    case 'VariableDeclaration':
        car.spawnMove(inDir, 'b');
        car.label(child.kind);
        for(var i = 0; i < child.declarations.length; ++i) {
            var decl = child.declarations[i];
            car.push();
            switch(decl.type) {
            case "VariableDeclarator":
                this.buildChild(decl.id, 'i');
                break;
            default:
                throw new Error("NYI");
            }
            car.pop();

            if(decl.init) {
                car.push();
                car.spawnMove('f', 'bu');
                car.label('=');
                this.buildChild(decl.init, 'f');
                car.pop();
            }
        }
        break;
    case "FunctionExpression":
    case "FunctionDeclaration":
        car.spawnMove(inDir, 'b');
        car.label('function');
        car.push();

        // Name
        if(child.id) {
            car.push();
            this.buildChild(child.id, 'i');
            car.pop();
        }

        // Parameters.
        car.pull(inDir);
        car.spawnMove(inDir, 'b');
        for(var i = 0; i < child.params; ++i) {
            car.spawnMove(inDir, 's');
        }
        car.pop();

        // Body.
        this.buildBody(child.body, parsegraph_DOWNWARD, parsegraph_DOWNWARD);
        car.shrink(parsegraph_DOWNWARD);
        break;
    default:
        car.spawnMove(inDir, 'b');
        car.label(child.type);
        break;
    }
};

/**
 * Builds each child node of a given AST node, creating the first bud in the inDir, and
 * then spawning each subsequent bud in the spawnDir direction.
 *
 * If spawnDir === parsegraph_FORWARD, then the child graph will be downward and centered.
 * If spawnDir === parsegraph_DOWNWARD, then the child graph will be forward and narrow.
 */
parsegraph_JavaScriptWidget.prototype.buildBody = function(ast, inDir, spawnDir)
{
    if(ast.body.length === 0) {
        return;
    }

    var car = this.caret;
    car.push();

    if(ast.body.length === 1) {
        car.pull(spawnDir);
        this.buildChild(ast.body[0], spawnDir);
        car.pop();
        return;
    }

    car.spawn(inDir, 'bu');
    if(spawnDir === parsegraph_FORWARD) {
        car.align(inDir, 'center');
    }
    car.move(inDir);
    for(var i = 0; i < ast.body.length; ++i) {
        if(i > 0) {
            car.spawnMove(spawnDir, 'bu');
        }

        var realSpawnDir = parsegraph_alternateNodeDirection(spawnDir);
        car.pull(realSpawnDir);
        car.push();
        this.buildChild(ast.body[i], realSpawnDir);
        car.pop();
    }
    car.pop();
};

parsegraph_JavaScriptWidget.prototype.load = function(url)
{
    var that = this;
    function buildTree() {
        var ast = esprima.parse(this.responseText);
        console.log(ast);

        var car = that.caret;
        car.moveToRoot();
        car.erase('f');
        car.erase('d');

        car.label(url);
        car.spawnMove('i', 's');
        car.label(ast.sourceType);
        car.move('o');

        that.buildBody(ast, parsegraph_DOWNWARD, parsegraph_FORWARD);

        that.graph.scheduleRepaint();
    }
    var oReq = new XMLHttpRequest();
    oReq.addEventListener("load", buildTree);
    oReq.open("GET", url);
    oReq.send();
};

function init()
{
    try {
        parsegraph_initialize();
        var main = document.body;

        // Create the surface.
        var surface = new parsegraph_Surface();
        main.appendChild(surface.container());

        var graph = new parsegraph_Graph(surface);
        GRAPH = graph;

        var widget = new parsegraph_JavaScriptWidget(graph);
        widget.load("primes.js");
        graph.world().plot(widget.caret.root());

        if(localStorage.getItem("parsegraph_world_camera") != null) {
            try {
                var parsegraph_world_camera = JSON.parse(localStorage.getItem("parsegraph_world_camera"));
                graph.camera().restore(parsegraph_world_camera);
            } catch(e) {
                console.log("Failed to parse saved camera state.\n" + parsegraph_writeError(e));
            }
        }

        var cameraProtocol = new parsegraph_CameraProtocol(new WebSocket(
            "ws://localhost/camera/", "parsegraph-camera-protocol"
        ), graph.camera(),
            function(obj) {
                graph.cameraBox().setCamera("dafrito", obj);
            }
        );

        var chatProtocol = new parsegraph_ChatProtocol(new WebSocket(
            "ws://localhost/chat/", "parsegraph-chat-protocol"
        ), function(obj) {
            //console.log("Message received: ", obj);
        });

        // Schedule the repaint.
        var renderTimer = new parsegraph_AnimationTimer();
        renderTimer.setListener(function() {
            graph.input().Update(new Date());
            if(graph.needsRepaint()) {
                surface.paint(50);
            }
            surface.render();
            if(graph.input().UpdateRepeatedly() || graph.needsRepaint()) {
                if(graph.input().UpdateRepeatedly()) {
                    cameraProtocol.update();
                }
                renderTimer.schedule();
            }
        });
        graph.input().SetListener(function(affectedPaint, eventSource, inputAffectedCamera) {
            if(affectedPaint) {
                graph.scheduleRepaint();
            }
            // Contrive a message to send over chat.
            chatProtocol.send(eventSource);
            renderTimer.schedule();
            if(inputAffectedCamera) {
                cameraProtocol.update();
                localStorage.setItem("parsegraph_world_camera", JSON.stringify(graph.camera().toJSON()));
            }
        });
        renderTimer.schedule();
        graph.onScheduleRepaint = function() {
            renderTimer.schedule();
        };
    } catch(ex) {
        alert("Init: " + parsegraph_writeError(ex));
        throw ex;
    }
}

document.addEventListener("DOMContentLoaded", function(event) {
    init();
});
</script>
</head>
<body>
</body>
</html>
