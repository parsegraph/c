<!DOCTYPE html>
<html>
<head>
<title>primes</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
    font-family: sans-serif;
    margin: 0;
    padding: 0;
}

.parsegraph_Surface {
    width: 100%;
    height: 100vh;
    margin: 0;
}

div {
    text-align: center;
    position: absolute;
}

.controls {
    margin: auto;
    position: absolute;
    pointer-events: none;
    width: 100%;
}

.controls > form button {
    pointer-events: auto;
}

@media only screen and (max-width: 980px) {

.controls {
    display: none;
}

body > div {
    width: 100%;
}

body > div input {
    clear: left;
}

}
</style>
<script src="parsegraph-1.3.js"></script>
<script src="parsegraph-widgets-1.3.js"></script>
<script>

function init()
{
    try {
        parsegraph_initialize(true);

        var main = document.body;

        var surface = new parsegraph_Surface();
        var graph = new parsegraph_Graph(surface);
        GRAPH = graph;

        var uni = new parsegraph_Unicode();
        uni.onLoad = function() {
            graph.setGlyphAtlas(parsegraph_buildGlyphAtlas());
            graph.glyphAtlas().setUnicode(uni);

            var COUNT = 25
            main.appendChild(graph.container());

            //var linear = new parsegraph_LinearWidget(graph);
            //graph.plot(linear.root());
            var primes = new parsegraph_PrimesWidget(graph);
            graph.plot(primes.root());

            var defaultScale = .25;
            graph.camera().project();
            graph.camera().setOrigin(
                graph.gl().drawingBufferWidth / (2 * defaultScale),
                graph.gl().drawingBufferHeight / (2 * defaultScale)
            );
            graph.camera().setScale(defaultScale);

            var MAX_PRIME = 440;
            var LOOPING_DELAY = 50;

            var bTimer = new parsegraph_TimeoutTimer();
            bTimer.setDelay(10);
            bTimer.setListener(function() {
                primes.step(1);
                graph.scheduleRepaint();
                renderTimer.schedule();
                if(primes.position <= MAX_PRIME) {
                    bTimer.setDelay(LOOPING_DELAY);
                    bTimer.schedule();
                }
            });
            bTimer.schedule();

            /*
            var aTimer = new parsegraph_TimeoutTimer();
            aTimer.setDelay(10);
            aTimer.setListener(function() {
                linear.step(1);
                graph.scheduleRepaint();
                renderTimer.schedule();
                if(primes.position <= MAX_PRIME) {
                    aTimer.setDelay(LOOPING_DELAY);
                    aTimer.schedule();
                }
            });
            aTimer.schedule();
            */

            var renderTimer = new parsegraph_AnimationTimer();
            renderTimer.setListener(function() {
                graph.input().Update(new Date());
                if(graph.needsRepaint()) {
                    surface.paint(30);
                }
                if(parsegraph_glBufferData_BYTES > 0) {
                    //console.log("Wrote " + parsegraph_glBufferData_BYTES + " in pagingbuffer");
                    parsegraph_clearPerformanceCounters();
                }
                surface.render();
                if(graph.input().UpdateRepeatedly() || graph.needsRepaint()) {
                    renderTimer.schedule();
                }
            });

            graph.input().SetListener(function(affectedPaint) {
                if(affectedPaint) {
                    graph.scheduleRepaint();
                }
                renderTimer.schedule();
            });
            renderTimer.schedule();
        };
        uni.load();
        parsegraph_UNICODE_INSTANCE = uni;
    } catch(ex) {
        alert("Init: " + parsegraph_writeError(ex));
        throw ex;
    }
}

document.addEventListener("DOMContentLoaded", function(event) {
    init();
});
</script>
</head>
<body>
</body>
</html>
