<!DOCTYPE html>
<html>
<head>
<title>Parsegraph Test</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
    font-family: sans-serif;
    margin: 0;
    padding: 0;
}

.parsegraph_Surface {
    width: 100%;
    height: 100vh;
    margin: 0;
}

div {
    text-align: center;
    position: absolute;
}

.controls {
    margin: auto;
    position: absolute;
    pointer-events: none;
    width: 100%;
}

.controls > form button {
    pointer-events: auto;
}

@media only screen and (max-width: 980px) {

.controls {
    display: none;
}

body > div {
    width: 100%;
}

body > div input {
    clear: left;
}

}
</style>
<script src="parsegraph-1.0.js"></script>
<script src="parsegraph-examples-1.0.js"></script>
<script>

function init()
{
    try {
        parsegraph_initialize(true);

        var main = document.body;

        var surface = new parsegraph_Surface();
        var graph = new parsegraph_Graph(surface);
        GRAPH = graph;

        var COUNT = 25
        main.appendChild(graph.container());

        var linear = new parsegraph_LinearWidget(graph);
        graph.plot(linear.root());
        var primes = new parsegraph_PrimesWidget(graph);
        graph.plot(primes.root());

        var defaultScale = .25;
        graph.camera().project();
        graph.camera().setOrigin(
            graph.gl().drawingBufferWidth / (2 * defaultScale),
            graph.gl().drawingBufferHeight / (2 * defaultScale)
        );
        graph.camera().setScale(defaultScale);

        var MAX_PRIME = 1000;
        var LOOPING_DELAY = 50;

        var bTimer = new parsegraph_TimeoutTimer();
        bTimer.setDelay(10);
        bTimer.setListener(function() {
            primes.step(1);
            graph.scheduleRepaint();
            renderTimer.schedule();
            if(primes.position <= MAX_PRIME) {
                bTimer.setDelay(LOOPING_DELAY);
                bTimer.schedule();
            }
        });
        bTimer.schedule();

        /*
        var aTimer = new parsegraph_TimeoutTimer();
        aTimer.setDelay(10);
        aTimer.setListener(function() {
            linear.step(1);
            graph.scheduleRepaint();
            renderTimer.schedule();
            if(primes.position <= MAX_PRIME) {
                aTimer.setDelay(LOOPING_DELAY);
                aTimer.schedule();
            }
        });
        aTimer.schedule();
        */

        var renderTimer = new parsegraph_AnimationTimer();
        renderTimer.setListener(function() {
            graph.input().Update(new Date());
            if(graph.needsRepaint()) {
                surface.paint(10);
            }
            surface.render();
            if(graph.input().UpdateRepeatedly() || graph.needsRepaint()) {
                renderTimer.schedule();
            }
        });

        graph.input().SetListener(function(affectedPaint) {
            if(affectedPaint) {
                graph.scheduleRepaint();
            }
            renderTimer.schedule();
        });
        renderTimer.schedule();

        var glyphAtlas = new parsegraph_GlyphAtlas(
            parsegraph_TextPainter_UPSCALED_FONT_SIZE, "sans-serif", "white"
        );
        var shaders = {};
        var textPainter = new parsegraph_TextPainter(surface.gl(), glyphAtlas, shaders);

surface.addRenderer(function() {
    var gl = surface.gl();

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.enable(gl.BLEND);
    gl.blendFunc(
        gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA
    );
    textPainter.clear();
    textPainter.setColor(1, 1, 1);

    textPainter.setFontSize(20);

    var drawMultiline = function(x, y, text) {
        var lines = text.split("\n");
        for(var i = 0; i < lines.length; ++i) {
            var line = lines[i];
            textPainter.drawText(line, x, y + (1 + i) * textPainter.fontSize());
        }
    };

    var t = "";
    t += "position=" + primes.position + "\n";
    //drawMultiline(8, 4, t);
    var world = textCamera.project();
    textPainter.render(world);
});

        var textCamera = new parsegraph_Camera(surface);

        var controls = document.createElement("div");
        controls.className = "controls";
        main.appendChild(controls);
        controls.style.bottom = ".5em";

        var form = parsegraph_createForm();
        form.button("resetOrigin", "Reset Camera");

        form.addListener(function(sourceName, value) {
            if(sourceName == "resetOrigin") {
                graph.camera().setOrigin(
                    graph.gl().drawingBufferWidth / (2 * defaultScale),
                    graph.gl().drawingBufferHeight / (2 * defaultScale)
                );
                graph.camera().setScale(defaultScale);
            }
            else {
                return;
            }
        });

        controls.appendChild(form.asDOM());
        main.appendChild(document.createElement("div"));
    } catch(ex) {
        alert("Init: " + parsegraph_writeError(ex));
        throw ex;
    }
}

document.addEventListener("DOMContentLoaded", function(event) {
    init();
});
</script>
</head>
<body>
</body>
</html>
