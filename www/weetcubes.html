<!DOCTYPE html>
<html>
<head>
<title>Alpha</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

.parsegraph_Surface {
    width: 100%;
    height: 100%;
}

body {
    font-family: sans-serif;
    margin: 0;
    padding: 0;
    background: #111;
    color: #eee;
}

body > div {
    text-align: center;
    position: absolute;
}

.Successful {
    color: green;
}

.Crashed {
    color: maroon;
}

.Failed {
    color: red;
}

@media only screen and (max-width: 980px) {

body > div {
    width: 100%;
}

body > div input {
    clear: left;
}

}
</style>
<script src="parsegraph-1.0.js"></script>
<script src="parsegraph-examples-1.0.js"></script>
<script>

function alpha_WeetCubeWidget()
{
    var surface;
    if(arguments.length === 0) {
        surface = new parsegraph_Surface();
    }
    else {
        surface = arguments[0];
    }
    this.surface = surface;

    this.camera = new alpha_Camera(surface);
    this.camera.SetFovX(60);
    this.camera.SetFarDistance(1000);
    this.camera.SetNearDistance(.1);
    this.camera.SetPosition(-1, -1, -550);

    this.input = new alpha_Input(surface, this.camera);
    this.input.SetMouseSensitivity(.4);

    this.surface.addPainter(this.paint, this);
    this.surface.addRenderer(this.render, this);

    this.cubePainter = null;
    this.rotq = 0;
}

alpha_WeetCubeWidget.prototype.paint = function(elapsed)
{
    if(elapsed === undefined || Number.isNaN(elapsed)) {
        throw new Error("elapsed must be provided.");
    }

    this.input.Update(elapsed);

    if(!this.cubePainter) {
        this.cubePainter = new alpha_WeetPainter(this.surface.gl());
    }
    else {
        this.cubePainter.Clear();
    }

    var rotq = this.rotq;
    var max = 15;

    for(var i = 0; i < max; ++i) {
        for(var j = 0; j < max; ++j) {
            for(var k = 0; k < max; ++k) {
                if(k % 2 != 0 || j % 2 != 0 || i % 2 != 0) {
                    continue;
                }

                // XXX The physical translates, then rotates, whereas the original
                // scene rotated first, then translated. Either the internal calculations
                // for Physical need to be worked out here, or a new Physical that rotates
                // before translating could be made.
                // glRotate(rotq*k/10, 0, 1, 1);
                // glRotate(rotq*i/15, 1, 0, 0);
                // glRotate(rotq*j/10, 1, 0, 1);
                // glTranslate(10*i, 10*j, 10*k);
                var c = new alpha_Physical(this.camera);
                c.Rotate(rotq*k/10, 0, 1, 1);
                c.Rotate(rotq*i/15, 1, 0, 0);
                c.Rotate(rotq*j/10, 1, 0, 1);
                c.SetPosition(10*i, 10*j, 10*k);
                c.SetScale(5, 5, 5);
                this.cubePainter.Cube(c);
            }
        }

        // Not really necessary, but just constraining the value of this so it
        // doesn't get massive when running in the background.
        if(rotq >= 360) {
            rotq = 0;
        }
        rotq = rotq + 0.1 * elapsed;
    }

    this.rotq = rotq;
};

alpha_WeetCubeWidget.prototype.render = function()
{
    var projection = this.camera.UpdateProjection();
    var viewMatrix = this.camera.GetViewMatrix().Multiplied(projection);
    this.cubePainter.Draw(viewMatrix);
};

document.addEventListener("DOMContentLoaded", function(event) {

parsegraph_initialize();

var surface = new parsegraph_Surface();
document.body.appendChild(surface.container());

surface.addRenderer(function() {
    var gl = surface.gl();
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
});

var widget = new alpha_WeetCubeWidget(surface);

surface.addRenderer(function() {
    var gl = surface.gl();
    gl.clear(gl.DEPTH_BUFFER_BIT);
});

// This flag is used to squelch rendering if that function
// threw an exception and failed to complete.
var speed=.6;
//surface.camera.setCameraPosition(0, 0, 550);
var start = alpha_GetTime();
var tick = function(t) {
    // Set the render flag.
    var t = alpha_GetTime();
    surface.paint(t - start);
    start = t;
    surface.render();

    // Reschedule.
    tickIntervalId = requestAnimationFrame(tick)
};
tickIntervalId = requestAnimationFrame(tick);

}); // DOMContentLoaded
</script>
</head>
<body>
