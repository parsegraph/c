<!DOCTYPE html>
<html>
<head>
<title>Alpha</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

.parsegraph_Surface {
    width: 100%;
    height: 100%;
}

body {
    font-family: sans-serif;
    margin: 0;
    padding: 0;
    background: #111;
    color: #eee;
}

body > div {
    text-align: center;
    position: absolute;
}

.Successful {
    color: green;
}

.Crashed {
    color: maroon;
}

.Failed {
    color: red;
}

@media only screen and (max-width: 980px) {

body > div {
    width: 100%;
}

body > div input {
    clear: left;
}

}
</style>
<script src="parsegraph-1.0.js"></script>
<script src="parsegraph-examples-1.0.js"></script>
<script>

function alpha_WeetCubeWidget()
{
    var surface;
    if(arguments.length === 0) {
        surface = new parsegraph_Surface();
    }
    else {
        surface = arguments[0];
    }
    this.surface = surface;

    this.surface.addPainter(this.paint, this);
    this.surface.addRenderer(this.render, this);

    this.cubePainter = null;
    this.rotq = 0;
}

alpha_WeetCubeWidget.prototype.paint = function()
{
    if(!this.cubePainter) {
        this.cubePainter = new alpha_WeetPainter(this.surface.gl());
    }
    else {
        this.cubePainter.Clear();
    }

    var rotq = this.rotq;
    var max = 5;

    var cubeSize = 10;
    for(var i = 0; i < max; ++i) {
        for(var j = 0; j < max; ++j) {
            for(var k = 0; k < max; ++k) {
                if(k % 2 != 0 || j % 2 != 0 || i % 2 != 0) {
                    continue;
                }

                var m = new alpha_Matrix();
                m.Rotate(alpha_QuaternionFromAxisAndAngle(
                    0, 1, 1, rotq*k/10
                ));
                m.Rotate(alpha_QuaternionFromAxisAndAngle(
                    1, 0, 0, rotq*i/15
                ));
                m.Rotate(alpha_QuaternionFromAxisAndAngle(
                    1, 0, 1, rotq*j/10
                ));
                m.Translate(20*cubeSize*i, 20*cubeSize*j, 20*cubeSize*k);
                this.cubePainter.Cube(m, cubeSize);
            }
        }

        // Not really necessary, but just constraining the value of this so it
        // doesn't get massive when running in the background.
        if(rotq >= 360) {
            rotq = 0;
        }
        rotq = rotq + 0.1;
    }

    this.rotq = rotq;
};

alpha_WeetCubeWidget.prototype.render = function()
{
    // http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
    // Lookup the size the browser is displaying the canvas.
    var displayWidth = this.surface.container().clientWidth;
    var displayHeight = this.surface.container().clientHeight;

    if(displayWidth == 0 || displayHeight == 0) {
        //console.log("No projection available.");
        return;
    }

    // Check if the canvas is not the same size.
    if(
        this.surface.canvas().width != displayWidth
        || this.surface.canvas().height != displayHeight
    ) {
        // Make the canvas the same size
        this.surface.canvas().width = displayWidth;
        this.surface.canvas().height = displayHeight;

        // Set the viewport to match
        this.surface.gl().viewport(
            0, 0, this.surface.canvas().width, this.surface.canvas().height
        );
    }

    this.width = this.surface.canvas().width;
    this.height = this.surface.canvas().height;

    var gl = this.surface.gl();
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    var projection = new alpha_Matrix(makePerspective(
        Math.PI * 60 / 180,
        this.width / this.height,
        1,
        100
    ));
    this.cubePainter.Draw(projection);
};

document.addEventListener("DOMContentLoaded", function(event) {

parsegraph_initialize();

var surface = new parsegraph_Surface();

var widget = new alpha_WeetCubeWidget(surface);

/*
local startX, startY;
widget:connect("mousePressed", function(button, x, y)
	startX = x;
	startY = y;
	print(button);
end);

widget:connect("mouseMoved", function(x, y)
	local deltaX = x - startX;
	local deltaY = y - startY;
	startX = x;
	startY = y;
	local cameraX, cameraY, cameraZ = widget:getCameraPosition();
	cameraX = cameraX + (deltaX / 2);
	cameraY = cameraY - (deltaY / 2)
	widget:setCameraPosition(cameraX, cameraY, cameraZ);
end);

widget:connect("keyPressed", function(key)
	print(key);
end);
*/

// This flag is used to squelch rendering if that function
// threw an exception and failed to complete.
var speed=.6;
//surface.camera.setCameraPosition(0, 0, 550);
var tick = function(t) {
    // Set the render flag.
    surface.paint();
    surface.render();

/*var total = 0;
local function Position(elapsed)
	total = total + (elapsed*speed);
	widget:setCameraRotation(0, 0, 0);
end;
Position(0);
Undoer(Timing.Every(Position));
*/

    tickIntervalId = window.setTimeout(tick, 50);
}; // Tick
tickIntervalId = window.setTimeout(tick, 50);

document.body.appendChild(surface.container());

}); // DOMContentLoaded
</script>
</head>
<body>
