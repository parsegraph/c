<!DOCTYPE html>
<html>
<head>
<title>Alpha</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

.parsegraph_Surface {
    width: 100%;
    height: 100%;
}

body {
    font-family: sans-serif;
    margin: 0;
    padding: 0;
    background: #111;
    color: #eee;
}

body > div {
    text-align: center;
    position: absolute;
}

.Successful {
    color: green;
}

.Crashed {
    color: maroon;
}

.Failed {
    color: red;
}

@media only screen and (max-width: 980px) {

body > div {
    width: 100%;
}

body > div input {
    clear: left;
}

}
</style>
<script src="parsegraph-1.0.js"></script>
<script src="parsegraph-examples-1.0.js"></script>
<script>

function alpha_WeetCubeWidget()
{
    var surface;
    if(arguments.length === 0) {
        surface = new parsegraph_Surface();
    }
    else {
        surface = arguments[0];
    }
    this.surface = surface;
    this.origin = new alpha_Vector();
    this.rotation = 0;

    this.surface.addPainter(this.paint, this);
    this.surface.addRenderer(this.render, this);

    this.cubePainter = null;
    this.rotq = 0;
}

alpha_WeetCubeWidget.prototype.paint = function(elapsed)
{
    if(elapsed === undefined || Number.isNaN(elapsed)) {
        throw new Error("elapsed must be provided.");
    }
    if(!this.cubePainter) {
        this.cubePainter = new alpha_WeetPainter(this.surface.gl());
    }
    else {
        this.cubePainter.Clear();
    }

    var rotq = this.rotq;
    var max = 1;

    for(var i = 0; i < max; ++i) {
        for(var j = 0; j < max; ++j) {
            for(var k = 0; k < max; ++k) {
                if(k % 2 != 0 || j % 2 != 0 || i % 2 != 0) {
                    continue;
                }

                var m = new alpha_RMatrix4();
                m.Translate(20*i, 20*j, 20*k);
                m.Rotate(alpha_QuaternionFromAxisAndAngle(
                    0, 1, 1, rotq*k/10
                ));
                m.Rotate(alpha_QuaternionFromAxisAndAngle(
                    1, 0, 0, rotq*i/15
                ));
                m.Rotate(alpha_QuaternionFromAxisAndAngle(
                    1, 0, 1, rotq*j/10
                ));
                this.cubePainter.Cube(m);
            }
        }

        // Not really necessary, but just constraining the value of this so it
        // doesn't get massive when running in the background.
        if(rotq >= 360) {
            rotq = 0;
        }
        //rotq = rotq + 0.01 * elapsed;
    }

    this.rotq = rotq;
};

alpha_WeetCubeWidget.prototype.setOrigin = function()
{
    this.origin.Set.apply(this.origin, arguments);
};

alpha_WeetCubeWidget.prototype.render = function()
{
    // http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
    // Lookup the size the browser is displaying the canvas.
    var displayWidth = this.surface.container().clientWidth;
    var displayHeight = this.surface.container().clientHeight;

    if(displayWidth == 0 || displayHeight == 0) {
        //console.log("No projection available.");
        return;
    }

    // Check if the canvas is not the same size.
    if(
        this.surface.canvas().width != displayWidth
        || this.surface.canvas().height != displayHeight
    ) {
        // Make the canvas the same size
        this.surface.canvas().width = displayWidth;
        this.surface.canvas().height = displayHeight;

        // Set the viewport to match
        this.surface.gl().viewport(
            0, 0, this.surface.canvas().width, this.surface.canvas().height
        );
    }

    this.width = this.surface.canvas().width;
    this.height = this.surface.canvas().height;

    var gl = this.surface.gl();
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    var projection = new alpha_RMatrix4(makePerspective(
        Math.PI * 60 / 180,
        this.width / this.height,
        .1,
        10000
    ));
    var view = new alpha_RMatrix4();
    view.Rotate(alpha_QuaternionFromAxisAndAngle(1, 0, 1, this.rotation * Math.PI));
    view.Translate(this.origin);
    view.Inverse();
    this.cubePainter.Draw(projection.Multiplied(view).Transpose());
};

document.addEventListener("DOMContentLoaded", function(event) {

parsegraph_initialize();

var surface = new parsegraph_Surface();
document.body.appendChild(surface.container());

var widget = new alpha_WeetCubeWidget(surface);

surface.addRenderer(function() {
    surface.gl().clear(surface.gl().DEPTH_BUFFER_BIT);
});

var graph = new parsegraph_Graph(surface);
GRAPH = graph;

var caret = new parsegraph_Caret(graph, 'bud');
caret.spawnMove('d', 'block', 'center');
caret.label("X");
caret.pull('d');
var xSlider = caret.spawn('d', 'slider');
xSlider.setValue(0);
caret.spawnMove('f', 'block');
caret.label("Y");
var ySlider = caret.spawn('d', 'slider');
ySlider.setValue(0);

caret.spawnMove('f', 'block');
caret.label("Z");
var zSlider = caret.spawn('d', 'slider');
zSlider.setValue(0);

caret.spawnMove('f', 'block');
caret.label("Rotation");
var rotSlider = caret.spawn('d', 'slider');
rotSlider.setValue(0);

graph.plot(caret);

/*
local startX, startY;
widget:connect("mousePressed", function(button, x, y)
	startX = x;
	startY = y;
	print(button);
end);

widget:connect("mouseMoved", function(x, y)
	local deltaX = x - startX;
	local deltaY = y - startY;
	startX = x;
	startY = y;
	local cameraX, cameraY, cameraZ = widget:getCameraPosition();
	cameraX = cameraX + (deltaX / 2);
	cameraY = cameraY - (deltaY / 2)
	widget:setCameraPosition(cameraX, cameraY, cameraZ);
end);

widget:connect("keyPressed", function(key)
	print(key);
end);
*/

// This flag is used to squelch rendering if that function
// threw an exception and failed to complete.
var speed=.6;
//surface.camera.setCameraPosition(0, 0, 550);
var start = alpha_GetTime();
var tick = function(t) {
    // Set the render flag.
    var t = alpha_GetTime();
    surface.paint(t - start);
    start = t;
    widget.setOrigin(
        xSlider.value(),
        ySlider.value(),
        40 * zSlider.value()
    );
    widget.rotation = (Math.PI / 2 + rotSlider.value() * 2 * Math.PI);
    surface.render();

/*var total = 0;
local function Position(elapsed)
	total = total + (elapsed*speed);
	widget:setCameraRotation(0, 0, 0);
end;
Position(0);
Undoer(Timing.Every(Position));
*/

    tickIntervalId = window.setTimeout(tick, 50);
}; // Tick
tickIntervalId = window.setTimeout(tick, 50);

graph.scheduleRepaint();

}); // DOMContentLoaded
</script>
</head>
<body>
